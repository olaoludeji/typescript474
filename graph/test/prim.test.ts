import { Edge, prim } from '../prim'

/**
 * @description Determines if two edges are equal or not by comparing their attributes
 * `a` and `b`. If they match, it checks if they have the same weight and compares
 * them accordingly.
 * 
 * @param { Edge } x - 2D coordinate of an edge in the grid, providing the necessary
 * information to determine if two edges are adjacent or not.
 * 
 * @param { Edge } y - 2nd edge in the comparison.
 * 
 * @returns { boolean } a boolean value indicating whether two edges are equal or not.
 */
const edge_equal = (x: Edge, y: Edge): boolean => {
  return (
    (x.a == y.a && x.b == y.b) ||
    (x.a == y.b && x.b == y.a && x.weight == y.weight)
  )
}

/**
 * @description Takes a pre-existing graph as input and then creates an undirected
 * tree by finding the minimum cost subgraph. It returns the resulting tree edges and
 * their corresponding cost, which are compared to the expected values.
 * 
 * @param { Edge[] } expected_tree_edges - edges of the tree to be formed, which are
 * used to compare with the actual tree edges generated by the prim algorithm.
 * 
 * @param { Edge[] } other_edges - edge not present in the expected tree edges, and
 * is used to test if any unexpected edges are present in the output of the prim algorithm.
 * 
 * @param { number } num_vertices - number of vertices in the graph, which is used
 * to create the correct size of arrays for storing the graph edges.
 * 
 * @param { number } expected_cost - cost of the expected minimum spanning tree, which
 * is compared to the output of the `prim()` function to validate the generated tree.
 */
const test_graph = (
  expected_tree_edges: Edge[],
  other_edges: Edge[],
  num_vertices: number,
  expected_cost: number
) => {
  // First make sure the graph is undirected
  const graph: [number, number][][] = []
  for (let _ = 0; _ < num_vertices; ++_) {
    graph.push([])
  }
  for (const edge of expected_tree_edges) {
    graph[edge.a].push([edge.b, edge.weight])
    graph[edge.b].push([edge.a, edge.weight])
  }
  for (const edge of other_edges) {
    graph[edge.a].push([edge.b, edge.weight])
    graph[edge.b].push([edge.a, edge.weight])
  }

  const [tree_edges, cost] = prim(graph)
  expect(cost).toStrictEqual(expected_cost)
  for (const expected_edge of expected_tree_edges) {
    expect(
      tree_edges.find((edge) => edge_equal(edge, expected_edge))
    ).toBeTruthy()
  }
  for (const unexpected_edge of other_edges) {
    expect(
      tree_edges.find((edge) => edge_equal(edge, unexpected_edge))
    ).toBeFalsy()
  }
}

/**
 * @description Performs various tests to validate the correctness of a tree-like
 * data structure represented as an array of arrays, where each inner array represents
 * an edge and each outer array represents a node, according to a given input and output.
 */
describe('prim', () => {
  it('should return empty tree for empty graph', () => {
    expect(prim([])).toStrictEqual([[], 0])
  })

  it('should return empty tree for single element graph', () => {
    expect(prim([])).toStrictEqual([[], 0])
  })

  it('should return correct value for two element graph', () => {
    expect(prim([[[1, 5]], []])).toStrictEqual([[new Edge(0, 1, 5)], 5])
  })

  it('should return the correct value', () => {
    const expected_tree_edges = [
      new Edge(0, 1, 1),
      new Edge(1, 3, 2),
      new Edge(3, 2, 3)
    ]

    const other_edges = [
      new Edge(0, 2, 4),
      new Edge(0, 3, 5),
      new Edge(1, 2, 6)
    ]

    test_graph(expected_tree_edges, other_edges, 4, 6)
  })

  it('should return the correct value', () => {
    const expected_tree_edges = [
      new Edge(0, 2, 2),
      new Edge(1, 3, 9),
      new Edge(2, 6, 74),
      new Edge(2, 7, 8),
      new Edge(3, 4, 3),
      new Edge(4, 9, 9),
      new Edge(5, 7, 5),
      new Edge(7, 9, 4),
      new Edge(8, 9, 2)
    ]

    const other_edges = [
      new Edge(0, 1, 10),
      new Edge(2, 4, 47),
      new Edge(4, 5, 42)
    ]

    test_graph(expected_tree_edges, other_edges, 10, 116)
  })
})
